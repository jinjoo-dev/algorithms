/**
 *  PROGRAMMERS SCHOOL
 *  https://school.programmers.co.kr/learn/courses/30/lessons/43105
 */

/*
    [7]          dp[0] =               [7]
   [3, 8]        dp[1] =             [10, 15]
  [8, 1, 0]      dp[2] =         [18, 11, 16, 15]
 [2, 7, 4, 4]    dp[3] =     [20, 25, 18, 15, 21, 19]
[4, 5, 2, 6, 5]  dp[4] = [24, 25, 30, 27, 20, 24, 21, 24]
*/

{
  /*
    시간 복잡도: O(n²)
    공간 복잡도: O(n²) → 원본 복 안면 O(1)+추가 공간
  
    마지막 줄보다 한 줄 위에서 시작하여 다음 줄의 동일 index 또는 index+1 위치에 해당하는 값 중 더 큰 수와 더하는 로직
    원본 데이터와 동일한 크기의 공간이 필요함

    [정확도 테스트]
    테스트 1 〉	통과 (0.15ms, 33.4MB)
    테스트 3 〉	통과 (0.16ms, 33.5MB)
    테스트 2 〉	통과 (0.15ms, 33.4MB)
    테스트 4 〉	통과 (0.20ms, 33.5MB)
    테스트 5 〉	통과 (0.53ms, 33.4MB)
    테스트 6 〉	통과 (0.24ms, 33.4MB)
    테스트 7 〉	통과 (0.50ms, 33.5MB)
    테스트 8 〉	통과 (0.23ms, 33.5MB)
    테스트 9 〉	통과 (0.15ms, 33.4MB)
    테스트 10 〉	통과 (0.19ms, 33.5MB)

    [효율성 테스트]
    테스트 1 〉	통과 (3.75ms, 41.2MB)
    테스트 2 〉	통과 (3.85ms, 40.1MB)
    테스트 3 〉	통과 (4.29ms, 41.9MB)
    테스트 4 〉	통과 (4.19ms, 41.3MB)
    테스트 5 〉	통과 (4.35ms, 40.8MB)
    테스트 6 〉	통과 (4.03ms, 42MB)
    테스트 7 〉	통과 (4.32ms, 41.6MB)
    테스트 8 〉	통과 (3.72ms, 40.7MB)
    테스트 9 〉	통과 (3.97ms, 40.9MB)
    테스트 10 〉	통과 (4.65ms, 41.8MB)
  */
  function solution(triangle) {
    const t = triangle.map((r) => r.slice()); // 원본 보존용
    for (let i = t.length - 2; i >= 0; i--) {
      for (let j = 0; j <= i; j++) {
        t[i][j] += Math.max(t[i + 1][j], t[i + 1][j + 1]);
      }
    }
    return t[0][0];
  }
}

{
  /*
    시간 복잡도: O(n²)
    공간 복잡도: O(n)

    마지막 줄을 기본으로 하는 배열 생성,
    마지막 줄보다 한 줄 위에서 시작하여 생성된 배열의 동일 index 또는 index+1 위치에 해당하는 값 중 더 큰 수와 더하는 로직
    원본 데이터의 가장 마지막 줄과 같은 크기의 공간이 필요함

    [정확도 테스트]
    테스트 1 〉	통과 (0.12ms, 33.5MB)
    테스트 2 〉	통과 (0.13ms, 33.4MB)
    테스트 3 〉	통과 (0.14ms, 33.4MB)
    테스트 4 〉	통과 (0.19ms, 33.3MB)
    테스트 5 〉	통과 (0.40ms, 33.5MB)
    테스트 6 〉	통과 (0.20ms, 33.5MB)
    테스트 7 〉	통과 (0.42ms, 33.6MB)
    테스트 8 〉	통과 (0.19ms, 33.4MB)
    테스트 9 〉	통과 (0.13ms, 33.4MB)
    테스트 10 〉	통과 (0.16ms, 33.4MB)
    
    [효율성 테스트] - 성능 갭이 큰 편
    테스트 1 〉	실패 (시간 초과)
    테스트 2 〉	통과 (2.64ms, 39.5MB)
    테스트 3 〉	통과 (3.16ms, 40.9MB)
    테스트 4 〉	통과 (2.73ms, 40.5MB)
    테스트 5 〉	통과 (3.04ms, 40.1MB)
    테스트 6 〉	통과 (26.69ms, 40.6MB)
    테스트 7 〉	통과 (27.89ms, 40.3MB)
    테스트 8 〉	통과 (3.09ms, 40MB)
    테스트 9 〉	통과 (3.10ms, 40.2MB)
    테스트 10 〉	통과 (2.91ms, 40.9MB)
  */
  function solution(triangle) {
    const n = triangle.length; // 아래 행을 복사해 시작
    const dp = triangle[n - 1].slice();
    for (let i = n - 2; i >= 0; i--) {
      for (let j = 0; j <= i; j++) {
        dp[j] = triangle[i][j] + Math.max(dp[j], dp[j + 1]);
      }
    }
    return dp[0];
  }
}

{
  /*
    시간 복잡도: O(n²)
    공간 복잡도: O(n²)

    [정확도 테스트]
    테스트 1 〉	통과 (0.18ms, 33.4MB)
    테스트 2 〉	통과 (0.66ms, 33.4MB)
    테스트 3 〉	통과 (0.22ms, 33.5MB)
    테스트 4 〉	통과 (0.25ms, 33.5MB)
    테스트 5 〉	통과 (0.68ms, 33.7MB)
    테스트 6 〉	통과 (0.33ms, 33.5MB)
    테스트 7 〉	통과 (0.66ms, 33.7MB)
    테스트 8 〉	통과 (0.31ms, 33.5MB)
    테스트 9 〉	통과 (0.18ms, 33.5MB)
    테스트 10 〉	통과 (0.24ms, 33.5MB)

    [효율성 테스트] - 성능 갭은 완만하나, 기본 속도가 느린 편
    테스트 1 〉	통과 (9.40ms, 42.4MB)
    테스트 2 〉	통과 (8.39ms, 41.2MB)
    테스트 3 〉	통과 (10.68ms, 43.4MB)
    테스트 4 〉	통과 (9.35ms, 42.5MB)
    테스트 5 〉	통과 (8.85ms, 42MB)
    테스트 6 〉	통과 (10.72ms, 43.6MB)
    테스트 7 〉	통과 (10.29ms, 43.1MB)
    테스트 8 〉	통과 (8.86ms, 41.7MB)
    테스트 9 〉	통과 (8.90ms, 42MB)
    테스트 10 〉	통과 (8.82ms, 43MB)

  */

  function solution(triangle) {
    const dp = Array.from({ length: triangle.length }, () => []);

    for (let i = 0; i < triangle.length; i += 1) {
      for (let j = 0; j < triangle[i].length; j += 1) {
        dp[i][j] =
          Math.max(dp[i - 1]?.[j] || 0, dp[i - 1]?.[j - 1] || 0) +
          triangle[i][j];
      }
    }

    return Math.max(...dp[dp.length - 1]);
  }
}
